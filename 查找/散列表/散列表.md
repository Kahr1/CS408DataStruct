# 散列表的相关概念

冲突

> 继续插入元素，但是根据当前元素对应的散列地址位置已经存储了元素，这种情况就是发生了冲突
>
> 构造更合适的散列函数可以减少冲突，但有时候冲突是不可避免的

减少冲突

1. 拉链法
   > 把所有的“同义词”存储在一个链表中
   >
2. 开放定址法
   > 如果发生“冲突”，就给新元素找一个空闲位置
   >

同义词

> 若不同的关键字通过散列函数映射到同一个存储地址,则称它们为“同义词”

# 散列函数的构造

## 设计散列函数需要注意什么

## 除留余数法（最常考最常用）

除数为不大于散列表表长最大的质数

表长为13，则可以令除数为13

表长为15，则可以令除数为13

适用场景：关键字连续即可

## 直接定址法

使用一个线性函数作为散列函数

适用场景：关键字分布基本连续

## 数字分析法

选取若干位分布均匀的若干位作为散列地址

适用场景：关键字集合已知，且关键字的某几个数码位分布均匀

## 平方取中法

这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀 。

适用场景：关键字的每位取值都不够均匀

# 处理冲突

## 拉链法

散列表中存储同义词链表的头指针

```c
#include <stdio.h>
#include <stdlib.h>
#define MaxSize 15

typedef int KeyType;
typedef struct LinkListNode
{
    KeyType key_value;
    struct LinkListNode* next;
} LinkListNode, *LinkList;

// 散列函数（除留余数法）
int HashFunction(KeyType key_value)
{
    return key_value % 13;
}

// 填入散列表
bool InsertHashTable(LinkListNode** hash_table, KeyType key_value)
{
    int hash_address = HashFunction(key_value);
    LinkListNode* new_node = (LinkListNode *)malloc(sizeof(LinkListNode));
    if (new_node == NULL)
    {
        return false;
    }
    new_node->key_value = key_value;
    new_node->next = hash_table[hash_address];
    hash_table[hash_address] = new_node;
    return true;
}

// 从散列表种删除关键字
bool DeleteHashTable(LinkListNode** hash_table, KeyType key_value)
{
    int hash_address = HashFunction(key_value);
    if (hash_table[hash_address] == NULL)
    {
        return false;
    }
    LinkListNode* free_node;
    if (hash_table[hash_address]->key_value == key_value)
    {
        free_node = hash_table[hash_address];
        hash_table[hash_address] = free_node->next;
        free(free_node);
    }
    else
    {
        LinkListNode* pre_node = hash_table[hash_address];
        while (pre_node->next != NULL && pre_node->next->key_value != key_value)
        {
            pre_node = pre_node->next;
        }
        if (pre_node->next != NULL)
        {
            free_node = pre_node->next;
            pre_node->next = free_node->next;
            free(free_node);
            return true;
        }
    }
    return false;
}

int main()
{
    KeyType key_value_array[12] = {19, 14, 23,01,68, 20, 84, 27, 55, 11,10,79};
    LinkListNode* hash_table[MaxSize] = {NULL};
    for (int i = 0; i < 12; i++)
    {
        InsertHashTable(hash_table, key_value_array[i]);
    }

    DeleteHashTable(hash_table, 19);
    return 0;
}
```
## 开放定址法
开放定址法：如果发生“冲突”，就给新元素找另一个空闲位置 。
一个散列地址，既可以向“同义词”开放，也可以向“非同义词”开放
发生冲突时，使用一个特殊的探测序列去确定下一个空闲的位置
### 线性探测法
### 平方探测法
### 双散列法
### 伪随机序列法