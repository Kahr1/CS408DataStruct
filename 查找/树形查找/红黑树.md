# 红黑树的相关概念
## 红黑树的满足条件
0. 红黑树是对二叉排序树的优化，所以它肯定是一棵二叉排序树，满足二叉排序书的要求
1. 每个结点或是红色，或是黑色的
2. 根节点是黑色的
3. 叶结点（外部结点、NULL结点、失败结点）均是黑色的
4. 不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）
5. 对每个结点，**从该节点到任一叶结点**的简单路径上，所含黑结点的数目相同
## 红黑树的性质
黑高bh：从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数

性质1：从根节点到叶结点的最长路径不大于最短路径的2倍
> 最长路径，就是红色节点穿插在黑色节点之间，保持路径最长；最短路径就是，整条路径上全是黑色节点
> 
性质2：有n个内部节点的红黑树高度$h≤2\log_2(𝑛+1)$红黑树查找操作时间复杂度=$O(\log_2 𝑛)$
> 证明：一个根节点黑高为$bh$的红黑树，其最少节点数为$2^{bh}-1$。假设一个树的高度为$h$，则根节点的黑高满足$bh >= \frac{h}{2}$，令黑高$bh = \frac{h}{2}$（最小黑高），则一个黑高最少为$\frac{h}{2}$的红黑树的节点总数满足$n >=2^{\frac{h}{2}}-1$，所以可得$h≤2\log_2(𝑛+1)$

> 保证了红黑树的查找效率为$O(\log_2n)$
# 红黑树节点结构
```c
typedef int ElemType;
typedef struct RedBlackTreeNode
{
    ElemType key_value;
    struct RedBlackTreeNode* parent;
    struct RedBlackTreeNode* left_child;
    struct RedBlackTreeNode* right_child;
    int node_color;
} RedBlackTreeNode, *RedBlackTree;
```
# 红黑树的查找
红黑树本身还是一个二叉排序树，所以查找操作和二叉排序树一样
# 红黑树的插入
> 边插入，边平衡（重新着色和旋转操作）

## 红黑树插入策略
1. 首先依据二叉排序树的性质，找到要插入的位置
