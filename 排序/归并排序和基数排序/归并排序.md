# 算法思想
# 算法实现
```c
#include <stdio.h>
#include <stdlib.h>
#define MaxSize 100

typedef int ElemType;
typedef struct
{
    ElemType data[MaxSize];
    int length;
} StaticSequenceList;

// 初始化顺序表
bool InitSequenceList(StaticSequenceList &SSL, int length)
{
    if (length == 0)
    {
        return false;
    }
    SSL.length = length;
    ElemType temp_value;
    for (int i = 0; i < SSL.length; i++)
    {
        scanf("%d", &temp_value);
        SSL.data[i] = temp_value;
    }
    return true;
}

// 遍历顺序表
bool TraverseSequenceList(StaticSequenceList SSL)
{
    if (SSL.length == 0)
    {
        return false;
    }
    for (int i = 0; i < SSL.length; i++)
    {
        printf("%3d", SSL.data[i]);
    }
    printf("\n");
    return true;
}

// 归并排序合并操作
bool Merge(StaticSequenceList &SSL, int low_index, int mid_index, int high_index)
{
    int i, j, k;
    static StaticSequenceList temp_SSL;
    for (k = low_index; k <= high_index; k++)
    {
        temp_SSL.data[k] = SSL.data[k];
    }
    for (i = low_index, j = mid_index+1, k = i; i <= mid_index && j <= high_index;)
    {
        if (temp_SSL.data[i] <= temp_SSL.data[j])
        {
            SSL.data[k++] = temp_SSL.data[i++];
        }
        else
        {
            SSL.data[k++] = temp_SSL.data[j++];
        }
    }
    while (i <= mid_index)
    {
        SSL.data[k++] = temp_SSL.data[i++];
    }
    while (j <= high_index)
    {
        SSL.data[k++] = temp_SSL.data[j++];
    }
    return true;
}

// 归并排序
bool MergeSort(StaticSequenceList &SSL, int low_index, int high_index)
{
    if (SSL.length == 0)
    {
        return false;
    }
    if (low_index < high_index)
    {
        int mid_index = (low_index + high_index) / 2;
        MergeSort(SSL, low_index, mid_index);
        MergeSort(SSL, mid_index + 1, high_index);
        Merge(SSL, low_index, mid_index, high_index);
        return true;
    }
    return false;
}

int main()
{
    StaticSequenceList SSL;
    InitSequenceList(SSL, 10);
    MergeSort(SSL, 0, SSL.length-1);
    TraverseSequenceList(SSL);
    return 0;
}
```
# 算法性能
