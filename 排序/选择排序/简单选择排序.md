# 算法思想

# 算法实现
```c
#include <stdio.h>
#include <stdlib.h>
#define MaxSize 100

typedef int ElemType;
typedef struct
{
    ElemType data[MaxSize];
    int length;
} StaticSequenceList;

// 遍历顺序表
bool TraverseSequenceList(StaticSequenceList SSL)
{
    if (SSL.length == 0)
    {
        return false;
    }
    for (int i = 0; i < SSL.length; i++)
    {
        printf("%3d", SSL.data[i]);
    }
    printf("\n");
    return true;
}

// 初始化顺序表
bool InitSequenceList(StaticSequenceList &SSL, int length)
{
    ElemType element_value;
    SSL.length = length;
    for (int i = 0; i < length; i++)
    {
        scanf("%d", &element_value);
        SSL.data[i] = element_value;
    }
    return true;
}

// 交换两个元素的值
bool Swap(ElemType &value1, ElemType &value2)
{
    ElemType temp_value = value1;
    value1 = value2;
    value2 = temp_value;
    return true;
}

// 简单选择排序
bool SimpleSelectionSort(StaticSequenceList &SSL)
{
    if (SSL.length == 0)
    {
        return false;
    }
    for (int i = 0; i < SSL.length-1; i++)
    {
        int min = i;
        for (int j = i + 1; j < SSL.length; j++)
        {
            if (SSL.data[min] > SSL.data[j])
            {
                min = j;
            }
        }
        if (min != i)
        {
            Swap(SSL.data[i], SSL.data[min]);
        }
    }
    return true;
}

int main()
{
    StaticSequenceList SSL;
    InitSequenceList(SSL, 10);
    TraverseSequenceList(SSL);
    SimpleSelectionSort(SSL);
    TraverseSequenceList(SSL);
    return 0;
}
```
# 性能分析
## 空间复杂度
## 时间复杂度
## 稳定性
举个例子，初始序列为: 2, **2**,1

简单选择排序之后得到的有序序列为1, **2**, 2

所以简单选择排序是不稳定的算法