# 算法思想

# 算法实现
```c
#include <stdio.h>
#include <stdlib.h>
#define MaxSize 100

typedef int ElemType;
typedef struct
{
    ElemType data[MaxSize];
    int length;
} StaticSequenceList;

// 遍历顺序表
bool TraverseSequenceList(StaticSequenceList SSL)
{
    if (SSL.length == 0)
    {
        return false;
    }
    for (int i = 0; i < SSL.length; i++)
    {
        printf("%3d", SSL.data[i]);
    }
    printf("\n");
    return true;
}

// 交换两个元素的值
bool Swap(ElemType &value1, ElemType &value2)
{
    ElemType temp_value = value1;
    value1 = value2;
    value2 = temp_value;
    return true;
}

// 初始化顺序表
bool InitSequenceList(StaticSequenceList &SSL, int length)
{
    if (length == 0)
    {
        return false;
    }
    SSL.length = length;
    ElemType temp_value;
    for (int i = 0; i < SSL.length; i++)
    {
        scanf("%d", &temp_value);
        SSL.data[i] = temp_value;
    }
    return true;
}

// 堆调整
bool HeapAdjust(StaticSequenceList &SSL, int root, int length)
{
    int parent_index = root;
    int child_index = root * 2 + 1;
    while (child_index < length)
    {
        if (child_index + 1 < length && SSL.data[child_index] < SSL.data[child_index+1])
        {
            child_index++;
        }
        if (SSL.data[parent_index] < SSL.data[child_index])
        {
            Swap(SSL.data[parent_index], SSL.data[child_index]);
            parent_index = child_index;
            child_index = parent_index * 2 + 1;
        }
        else
        {
            break;
        }
    }
    return true;
}

// 建立大根堆
bool BuildMaxHeap(StaticSequenceList &SSL)
{
    for (int i = SSL.length / 2 - 1; i >= 0; i--)
    {
        HeapAdjust(SSL, i, SSL.length);
    }
    return true;
}

// 堆排序
bool HeapSort(StaticSequenceList &SSL)
{
    if (SSL.length == 0)
    {
        return false;
    }
    BuildMaxHeap(SSL);
    for (int i = SSL.length-1; i > 0; i--)
    {
        Swap(SSL.data[0], SSL.data[i]);
        HeapAdjust(SSL, 0, i);
    }
    return true;
}

int main()
{
    StaticSequenceList SSL;
    InitSequenceList(SSL, 10);
    TraverseSequenceList(SSL);
    HeapSort(SSL);
    TraverseSequenceList(SSL);
    return 0;
}

```

# 性能分析
堆排的平均时间复杂度为$O(n\log_2 n)$
尽管堆排和快排的时间复杂度一样，但是在实际应用中的效率并没有比快速排序的效率高。但快排容易受序列顺序的影响，而堆排不受序列顺序的影响，并且在算法执行过程中只需要常数级别的空间支持。

空间换时间？万事万物均有利有弊，没有绝对的完美，只有适合
